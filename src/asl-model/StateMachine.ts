import AslNode from "./AslNode";
import AslState from "./AslState";
import {AlreadyExistsError, InvalidName, MissingFieldError, TooManyError} from "./errors";
import {isValidStateName} from "./utils";

export default class StateMachine extends AslNode {

    /** The state machine's initial state */
    private _startState?: string;

    /** the child states, in the order they were added */
    private _states: AslState[] = [];

    /** the most recent auto-generated state number provided */
    private _autogeneratedStateNumber = 0;

    /** If defined, is the state name to be returned in place of the next auto-generated state name */
    private _customStateName?: string = undefined;

    /** @returns the state machine's start state */
    public get startState(): string | undefined {
        return this._startState;
    }

    /** @param stateName the state machine's start state. */
    public set startState(stateName: string) {
        this._startState = stateName;
    }

    /**
     * Return the most recently added child state (the current last in the chain), or undefined
     * if there are no states.
     */
    public getLastState(): AslState | undefined {
        if (this._states.length === 0) {
            return undefined
        }
        return this._states[this._states.length - 1] as AslState;
    }

    /**
     * Append a new child state to this state machine. They will be stored in the order
     * they were added so the generated ASL will show them in a logical sequence.
     *
     * @param childState A child state to be added to the state machine.
     * @throws AlreadyExistsError If a state by the same name is already added.
     */
    public addChildState(childState: AslState) {
        /* search for existing state with the same name (linear search is OK given small data size). */
        if (this._states.find(state => state.name === childState.name)) {
            throw new AlreadyExistsError(`A state with name "${childState.name}" has already been added`);
        }
        this._states.push(childState);
    }

    /**
     * Return a valid and unique state name that can be assigned to a state (the next state,
     * or some future state). If a custom state name has provided, return that as the next
     * state name.
     */
    public get nextStateName(): string  {
        /* if a custom name was provided */
        if (this._customStateName) {
            const name = this._customStateName;
            this._customStateName = undefined
            return name;
        }

        /* else use the next auto-generated state name */
        this._autogeneratedStateNumber++;
        if (this._autogeneratedStateNumber == 10_000) {
            throw new RangeError("Maximum number of auto-generated state names exceeded")
        }

        /* pad to 4 digits */
        const digits = "000" + this._autogeneratedStateNumber
        const fourDigits = digits.substring(digits.length - 4);
        return `State${fourDigits}`
    }

    /**
     * Set a state name to be returned as the next auto-generated name. This is useful when a "label" operation
     * is used to give a meaningful name for a state machine name. It's also used for if-then-else statements (etc)
     * where state names must be generated first, then assigned to a state at a much later time.
     *
     * @param stateName The next state name to use.
     * @throws InvalidName if the name contains invalid characters, or looks like an auto-generated name.
     */
    public set nextStateName(stateName: string) {
        if (this._customStateName) {
            throw new TooManyError("A custom state name has already been provided, but not yet used");
        }
        if (!isValidStateName(stateName)) {
            throw new InvalidName(`State name ${stateName} is not legal`);
        }
        this._customStateName = stateName;
    }

    /**
     * @return true if there's a custom state name set, which hasn't yet been used.
     */
    public hasUnusedCustomStateName(): boolean {
        return this._customStateName != undefined;
    }

    /**
     * Helper for adding a new state to the state machine, then appending it to the end of
     * the current flow.
     *
     * @param state New state to be appended to the end.
     */
    public chainStateAtEnd(state: AslState) {
        const lastState = this.getLastState();
        this.addChildState(state)
        if (lastState === undefined) {
            this.startState = state.name;
        } else {
            lastState.next = state.name;
        }
    }

    /**
     * Return the number of states in the state machine.
     */
    public size(): number {
        return this._states.length
    }

    /**
     * Output this state machine's ASL, complete with top-level states
     * and the ASL for all child states (deeply recursive).
     *
     * @returns an object hierarchy that can later be stringified to JSON.
     */
    toAsl(): object {
        if (!this._startState) {
            throw new MissingFieldError("Mandatory field 'startState' is missing");
        }

        const asl: { [key: string]: any } = {
            "Version": "1.0",
            "QueryLanguage": "JSONata",
            "StartAt": this._startState
        }
        if (this.comment) {
            asl["Comment"] = this.comment;
        }

        const statesObject: { [key: string]: object } = {}
        this._states.find(state => {
            statesObject[state.name] = state.toAsl()
        })
        asl["States"] = statesObject;

        return asl as object;
    }
}